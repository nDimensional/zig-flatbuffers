.{
    .tables = .{
        .{
            .name = "org.apache.arrow.flatbuf.Binary",
            .fields = .{},
            .documentation = .{" Opaque binary data"},
        },
        .{
            .name = "org.apache.arrow.flatbuf.BinaryView",
            .fields = .{},
            .documentation = .{
                " Logically the same as Binary, but the internal representation uses a view",
                " struct that contains the string length and either the string's entire data",
                " inline (for small strings) or an inlined prefix, an index of another buffer,",
                " and an offset pointing to a slice in that buffer (for non-small strings).",
                "",
                " Since it uses a variable number of data buffers, each Field with this type",
                " must have a corresponding entry in `variadicBufferCounts`.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.BodyCompression",
            .fields = .{ .{
                .name = "codec",
                .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.CompressionType" } },
                .documentation = .{ " Compressor library.", " For LZ4_FRAME, each compressed buffer must consist of a single frame." },
            }, .{
                .name = "method",
                .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.BodyCompressionMethod" } },
                .documentation = .{" Indicates the way the record batch body was compressed"},
            } },
            .documentation = .{
                " Optional compression for the memory buffers constituting IPC message",
                " bodies. Intended for use with RecordBatch but could be used for other",
                " message types",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.Bool", .fields = .{} },
        .{
            .name = "org.apache.arrow.flatbuf.Date",
            .fields = .{.{
                .name = "unit",
                .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.DateUnit" } },
                .default_integer = 1,
            }},
            .documentation = .{
                " Date is either a 32-bit or 64-bit signed integer type representing an",
                " elapsed time since UNIX epoch (1970-01-01), stored in either of two units:",
                "",
                " * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no",
                "   leap seconds), where the values are evenly divisible by 86400000",
                " * Days (32 bits) since the UNIX epoch",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Decimal",
            .fields = .{
                .{
                    .name = "precision",
                    .type = .{ .int = .i32 },
                    .documentation = .{" Total number of decimal digits"},
                },
                .{
                    .name = "scale",
                    .type = .{ .int = .i32 },
                    .documentation = .{" Number of digits after the decimal point \".\""},
                },
                .{
                    .name = "bitWidth",
                    .type = .{ .int = .i32 },
                    .default_integer = 128,
                    .documentation = .{ " Number of bits per value. The accepted widths are 32, 64, 128 and 256.", " We use bitWidth for consistency with Int::bitWidth." },
                },
            },
            .documentation = .{
                " Exact decimal value represented as an integer value in two's",
                " complement. Currently 32-bit (4-byte), 64-bit (8-byte),",
                " 128-bit (16-byte) and 256-bit (32-byte) integers are used.",
                " The representation uses the endianness indicated in the Schema.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.DictionaryBatch",
            .fields = .{
                .{ .name = "id", .type = .{ .int = .i64 } },
                .{ .name = "data", .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.RecordBatch" } } },
                .{
                    .name = "isDelta",
                    .type = .bool,
                    .documentation = .{
                        " If isDelta is true the values in the dictionary are to be appended to a",
                        " dictionary with the indicated id. If isDelta is false this dictionary",
                        " should replace the existing dictionary.",
                    },
                },
            },
            .documentation = .{
                " For sending dictionary encoding information. Any Field can be",
                " dictionary-encoded, but in this case none of its children may be",
                " dictionary-encoded.",
                " There is one vector / column per dictionary, but that vector / column",
                " may be spread across multiple dictionary batches by using the isDelta",
                " flag",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.DictionaryEncoding", .fields = .{
            .{
                .name = "id",
                .type = .{ .int = .i64 },
                .documentation = .{
                    " The known dictionary id in the application where this data is used. In",
                    " the file or streaming formats, the dictionary ids are found in the",
                    " DictionaryBatch messages",
                },
            },
            .{
                .name = "indexType",
                .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                .documentation = .{
                    " The dictionary indices are constrained to be non-negative integers. If",
                    " this field is null, the indices must be signed int32. To maximize",
                    " cross-language compatibility and performance, implementations are",
                    " recommended to prefer signed integer types over unsigned integer types",
                    " and to avoid uint64 indices unless they are required by an application.",
                },
            },
            .{
                .name = "isOrdered",
                .type = .bool,
                .documentation = .{
                    " By default, dictionaries are not ordered, or the order does not have",
                    " semantic meaning. In some statistical, applications, dictionary-encoding",
                    " is used to represent ordered categorical data, and we provide a way to",
                    " preserve that metadata here",
                },
            },
            .{ .name = "dictionaryKind", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.DictionaryKind" } } },
        } },
        .{ .name = "org.apache.arrow.flatbuf.Duration", .fields = .{.{
            .name = "unit",
            .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.TimeUnit" } },
            .default_integer = 1,
        }} },
        .{
            .name = "org.apache.arrow.flatbuf.Field",
            .fields = .{
                .{
                    .name = "name",
                    .type = .string,
                    .documentation = .{" Name is not required (e.g., in a List)"},
                },
                .{
                    .name = "nullable",
                    .type = .bool,
                    .documentation = .{" Whether or not this field can contain nulls. Should be true in general."},
                },
                .{ .name = "type_type", .type = .{ .@"union" = .{ .name = "org.apache.arrow.flatbuf.Type" } } },
                .{
                    .name = "dictionary",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.DictionaryEncoding" } },
                    .documentation = .{" Present only if the field is dictionary encoded."},
                },
                .{
                    .name = "children",
                    .type = .{ .vector = .{
                        .element_size = 4,
                        .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Field" } },
                        .minalign = 4,
                    } },
                    .documentation = .{ " children apply only to nested data types like Struct, List and Union. For", " primitive types children will have length 0." },
                },
                .{
                    .name = "custom_metadata",
                    .type = .{ .vector = .{
                        .element_size = 4,
                        .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.KeyValue" } },
                        .minalign = 4,
                    } },
                    .documentation = .{" User-defined metadata"},
                },
            },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " A field represents a named column in a record / row batch or child of a",
                " nested type.",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.FixedSizeBinary", .fields = .{.{
            .name = "byteWidth",
            .type = .{ .int = .i32 },
            .documentation = .{" Number of bytes per value"},
        }} },
        .{ .name = "org.apache.arrow.flatbuf.FixedSizeList", .fields = .{.{
            .name = "listSize",
            .type = .{ .int = .i32 },
            .documentation = .{" Number of list items per value"},
        }} },
        .{ .name = "org.apache.arrow.flatbuf.FloatingPoint", .fields = .{.{ .name = "precision", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.Precision" } } }} },
        .{
            .name = "org.apache.arrow.flatbuf.Footer",
            .fields = .{
                .{ .name = "version", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.MetadataVersion" } } },
                .{ .name = "schema", .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Schema" } } },
                .{ .name = "dictionaries", .type = .{ .vector = .{
                    .element_size = 24,
                    .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Block" } },
                    .minalign = 8,
                } } },
                .{ .name = "recordBatches", .type = .{ .vector = .{
                    .element_size = 24,
                    .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Block" } },
                    .minalign = 8,
                } } },
                .{
                    .name = "custom_metadata",
                    .type = .{ .vector = .{
                        .element_size = 4,
                        .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.KeyValue" } },
                        .minalign = 4,
                    } },
                    .documentation = .{" User-defined metadata"},
                },
            },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " Arrow File metadata",
                "",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.Int", .fields = .{ .{ .name = "bitWidth", .type = .{ .int = .i32 } }, .{ .name = "is_signed", .type = .bool } } },
        .{ .name = "org.apache.arrow.flatbuf.Interval", .fields = .{.{ .name = "unit", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.IntervalUnit" } } }} },
        .{
            .name = "org.apache.arrow.flatbuf.KeyValue",
            .fields = .{ .{ .name = "key", .type = .string }, .{ .name = "value", .type = .string } },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " user defined key value pairs to add custom metadata to arrow",
                " key namespacing is the responsibility of the user",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.LargeBinary",
            .fields = .{},
            .documentation = .{ " Same as Binary, but with 64-bit offsets, allowing to represent", " extremely large data values." },
        },
        .{
            .name = "org.apache.arrow.flatbuf.LargeList",
            .fields = .{},
            .documentation = .{ " Same as List, but with 64-bit offsets, allowing to represent", " extremely large data values." },
        },
        .{
            .name = "org.apache.arrow.flatbuf.LargeListView",
            .fields = .{},
            .documentation = .{ " Same as ListView, but with 64-bit offsets and sizes, allowing to represent", " extremely large data values." },
        },
        .{
            .name = "org.apache.arrow.flatbuf.LargeUtf8",
            .fields = .{},
            .documentation = .{ " Same as Utf8, but with 64-bit offsets, allowing to represent", " extremely large data values." },
        },
        .{ .name = "org.apache.arrow.flatbuf.List", .fields = .{} },
        .{
            .name = "org.apache.arrow.flatbuf.ListView",
            .fields = .{},
            .documentation = .{
                " Represents the same logical types that List can, but contains offsets and",
                " sizes allowing for writes in any order and sharing of child values among",
                " list values.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Map",
            .fields = .{.{
                .name = "keysSorted",
                .type = .bool,
                .documentation = .{" Set to true if the keys within each value are sorted"},
            }},
            .documentation = .{
                " A Map is a logical nested type that is represented as",
                "",
                " List<entries: Struct<key: K, value: V>>",
                "",
                " In this layout, the keys and values are each respectively contiguous. We do",
                " not constrain the key and value types, so the application is responsible",
                " for ensuring that the keys are hashable and unique. Whether the keys are sorted",
                " may be set in the metadata for this field.",
                "",
                " In a field with Map type, the field has a child Struct field, which then",
                " has two children: key type and the second the value type. The names of the",
                " child fields may be respectively \"entries\", \"key\", and \"value\", but this is",
                " not enforced.",
                "",
                " Map",
                " ```text",
                "   - child[0] entries: Struct",
                "     - child[0] key: K",
                "     - child[1] value: V",
                " ```",
                " Neither the \"entries\" field nor the \"key\" field may be nullable.",
                "",
                " The metadata is structured so that Arrow systems without special handling",
                " for Map can make Map an alias for List. The \"layout\" attribute for the Map",
                " field must have the same contents as a List.",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.Message", .fields = .{
            .{ .name = "version", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.MetadataVersion" } } },
            .{ .name = "header_type", .type = .{ .@"union" = .{ .name = "org.apache.arrow.flatbuf.MessageHeader" } } },
            .{ .name = "bodyLength", .type = .{ .int = .i64 } },
            .{ .name = "custom_metadata", .type = .{ .vector = .{
                .element_size = 4,
                .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.KeyValue" } },
                .minalign = 4,
            } } },
        } },
        .{
            .name = "org.apache.arrow.flatbuf.Null",
            .fields = .{},
            .documentation = .{" These are stored in the flatbuffer in the Type union below"},
        },
        .{
            .name = "org.apache.arrow.flatbuf.RecordBatch",
            .fields = .{
                .{
                    .name = "length",
                    .type = .{ .int = .i64 },
                    .documentation = .{ " number of records / rows. The arrays in the batch should all have this", " length" },
                },
                .{
                    .name = "nodes",
                    .type = .{ .vector = .{
                        .element_size = 16,
                        .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.FieldNode" } },
                        .minalign = 8,
                    } },
                    .documentation = .{" Nodes correspond to the pre-ordered flattened logical schema"},
                },
                .{
                    .name = "buffers",
                    .type = .{ .vector = .{
                        .element_size = 16,
                        .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                        .minalign = 8,
                    } },
                    .documentation = .{
                        " Buffers correspond to the pre-ordered flattened buffer tree",
                        "",
                        " The number of buffers appended to this list depends on the schema. For",
                        " example, most primitive arrays will have 2 buffers, 1 for the validity",
                        " bitmap and 1 for the values. For struct arrays, there will only be a",
                        " single buffer for the validity (nulls) bitmap",
                    },
                },
                .{
                    .name = "compression",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.BodyCompression" } },
                    .documentation = .{" Optional compression of the message body"},
                },
                .{
                    .name = "variadicBufferCounts",
                    .type = .{ .vector = .{
                        .element_size = 8,
                        .element = .{ .int = .i64 },
                        .minalign = 8,
                    } },
                    .documentation = .{
                        " Some types such as Utf8View are represented using a variable number of buffers.",
                        " For each such Field in the pre-ordered flattened logical schema, there will be",
                        " an entry in variadicBufferCounts to indicate the number of number of variadic",
                        " buffers which belong to that Field in the current RecordBatch.",
                        "",
                        " For example, the schema",
                        "     col1: Struct<alpha: Int32, beta: BinaryView, gamma: Float64>",
                        "     col2: Utf8View",
                        " contains two Fields with variadic buffers so variadicBufferCounts will have",
                        " two entries, the first counting the variadic buffers of `col1.beta` and the",
                        " second counting `col2`'s.",
                        "",
                        " This field may be omitted if and only if the schema contains no Fields with",
                        " a variable number of buffers, such as BinaryView and Utf8View.",
                    },
                },
            },
            .documentation = .{
                " A data header describing the shared memory layout of a \"record\" or \"row\"",
                " batch. Some systems call this a \"row batch\" internally and others a \"record",
                " batch\".",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.RunEndEncoded",
            .fields = .{},
            .documentation = .{
                " Contains two child arrays, run_ends and values.",
                " The run_ends child array must be a 16/32/64-bit integer array",
                " which encodes the indices at which the run with the value in",
                " each corresponding index in the values child array ends.",
                " Like list/struct types, the value array can be of any type.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Schema",
            .fields = .{
                .{
                    .name = "endianness",
                    .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.Endianness" } },
                    .documentation = .{
                        " endianness of the buffer",
                        " it is Little Endian by default",
                        " if endianness doesn't match the underlying system then the vectors need to be converted",
                    },
                },
                .{ .name = "fields", .type = .{ .vector = .{
                    .element_size = 4,
                    .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Field" } },
                    .minalign = 4,
                } } },
                .{ .name = "custom_metadata", .type = .{ .vector = .{
                    .element_size = 4,
                    .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.KeyValue" } },
                    .minalign = 4,
                } } },
                .{
                    .name = "features",
                    .type = .{ .vector = .{
                        .element_size = 8,
                        .element = .{ .int = .i64 },
                        .minalign = 8,
                    } },
                    .documentation = .{" Features used in the stream/file."},
                },
            },
            .documentation = .{ " ----------------------------------------------------------------------", " A Schema describes the columns in a row batch" },
        },
        .{
            .name = "org.apache.arrow.flatbuf.SparseMatrixIndexCSX",
            .fields = .{
                .{
                    .name = "compressedAxis",
                    .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.SparseMatrixCompressedAxis" } },
                    .documentation = .{" Which axis, row or column, is compressed"},
                },
                .{
                    .name = "indptrType",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                    .required = true,
                    .documentation = .{" The type of values in indptrBuffer"},
                },
                .{
                    .name = "indptrBuffer",
                    .type = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                    .required = true,
                    .documentation = .{
                        " indptrBuffer stores the location and size of indptr array that",
                        " represents the range of the rows.",
                        " The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.",
                        " The length of this array is 1 + (the number of rows), and the type",
                        " of index value is long.",
                        "",
                        " For example, let X be the following 6x4 matrix:",
                        " ```text",
                        "   X := [[0, 1, 2, 0],",
                        "         [0, 0, 3, 0],",
                        "         [0, 4, 0, 5],",
                        "         [0, 0, 0, 0],",
                        "         [6, 0, 7, 8],",
                        "         [0, 9, 0, 0]].",
                        " ```",
                        " The array of non-zero values in X is:",
                        " ```text",
                        "   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].",
                        " ```",
                        " And the indptr of X is:",
                        " ```text",
                        "   indptr(X) = [0, 2, 3, 5, 5, 8, 10].",
                        " ```",
                    },
                },
                .{
                    .name = "indicesType",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                    .required = true,
                    .documentation = .{" The type of values in indicesBuffer"},
                },
                .{
                    .name = "indicesBuffer",
                    .type = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                    .required = true,
                    .documentation = .{
                        " indicesBuffer stores the location and size of the array that",
                        " contains the column indices of the corresponding non-zero values.",
                        " The type of index value is long.",
                        "",
                        " For example, the indices of the above X is:",
                        " ```text",
                        "   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].",
                        " ```",
                        " Note that the indices are sorted in lexicographical order for each row.",
                    },
                },
            },
            .documentation = .{" Compressed Sparse format, that is matrix-specific."},
        },
        .{ .name = "org.apache.arrow.flatbuf.SparseTensor", .fields = .{
            .{ .name = "type_type", .type = .{ .@"union" = .{ .name = "org.apache.arrow.flatbuf.Type" } } },
            .{
                .name = "shape",
                .type = .{ .vector = .{
                    .element_size = 4,
                    .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.TensorDim" } },
                    .minalign = 4,
                } },
                .required = true,
                .documentation = .{" The dimensions of the tensor, optionally named."},
            },
            .{
                .name = "non_zero_length",
                .type = .{ .int = .i64 },
                .documentation = .{" The number of non-zero values in a sparse tensor."},
            },
            .{ .name = "sparseIndex_type", .type = .{ .@"union" = .{ .name = "org.apache.arrow.flatbuf.SparseTensorIndex" } } },
            .{
                .name = "data",
                .type = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                .required = true,
                .documentation = .{" The location and size of the tensor's data"},
            },
        } },
        .{
            .name = "org.apache.arrow.flatbuf.SparseTensorIndexCOO",
            .fields = .{
                .{
                    .name = "indicesType",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                    .required = true,
                    .documentation = .{" The type of values in indicesBuffer"},
                },
                .{
                    .name = "indicesStrides",
                    .type = .{ .vector = .{
                        .element_size = 8,
                        .element = .{ .int = .i64 },
                        .minalign = 8,
                    } },
                    .documentation = .{ " Non-negative byte offsets to advance one value cell along each dimension", " If omitted, default to row-major order (C-like)." },
                },
                .{
                    .name = "indicesBuffer",
                    .type = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                    .required = true,
                    .documentation = .{" The location and size of the indices matrix's data"},
                },
                .{
                    .name = "isCanonical",
                    .type = .bool,
                    .documentation = .{
                        " This flag is true if and only if the indices matrix is sorted in",
                        " row-major order, and does not have duplicated entries.",
                        " This sort order is the same as of Tensorflow's SparseTensor,",
                        " but it is inverse order of SciPy's canonical coo_matrix",
                        " (SciPy employs column-major order for its coo_matrix).",
                    },
                },
            },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " EXPERIMENTAL: Data structures for sparse tensors",
                " Coordinate (COO) format of sparse tensor index.",
                "",
                " COO's index list are represented as a NxM matrix,",
                " where N is the number of non-zero values,",
                " and M is the number of dimensions of a sparse tensor.",
                "",
                " indicesBuffer stores the location and size of the data of this indices",
                " matrix.  The value type and the stride of the indices matrix is",
                " specified in indicesType and indicesStrides fields.",
                "",
                " For example, let X be a 2x3x4x5 tensor, and it has the following",
                " 6 non-zero values:",
                " ```text",
                "   X[0, 1, 2, 0] := 1",
                "   X[1, 1, 2, 3] := 2",
                "   X[0, 2, 1, 0] := 3",
                "   X[0, 1, 3, 0] := 4",
                "   X[0, 1, 2, 1] := 5",
                "   X[1, 2, 0, 4] := 6",
                " ```",
                " In COO format, the index matrix of X is the following 4x6 matrix:",
                " ```text",
                "   [[0, 0, 0, 0, 1, 1],",
                "    [1, 1, 1, 2, 1, 2],",
                "    [2, 2, 3, 1, 2, 0],",
                "    [0, 1, 0, 0, 3, 4]]",
                " ```",
                " When isCanonical is true, the indices is sorted in lexicographical order",
                " (row-major order), and it does not have duplicated entries.  Otherwise,",
                " the indices may not be sorted, or may have duplicated entries.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.SparseTensorIndexCSF",
            .fields = .{
                .{
                    .name = "indptrType",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                    .required = true,
                    .documentation = .{
                        " CSF is a generalization of compressed sparse row (CSR) index.",
                        " See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)",
                        "",
                        " CSF index recursively compresses each dimension of a tensor into a set",
                        " of prefix trees. Each path from a root to leaf forms one tensor",
                        " non-zero index. CSF is implemented with two arrays of buffers and one",
                        " arrays of integers.",
                        "",
                        " For example, let X be a 2x3x4x5 tensor and let it have the following",
                        " 8 non-zero values:",
                        " ```text",
                        "   X[0, 0, 0, 1] := 1",
                        "   X[0, 0, 0, 2] := 2",
                        "   X[0, 1, 0, 0] := 3",
                        "   X[0, 1, 0, 2] := 4",
                        "   X[0, 1, 1, 0] := 5",
                        "   X[1, 1, 1, 0] := 6",
                        "   X[1, 1, 1, 1] := 7",
                        "   X[1, 1, 1, 2] := 8",
                        " ```",
                        " As a prefix tree this would be represented as:",
                        " ```text",
                        "         0          1",
                        "        / \\         |",
                        "       0   1        1",
                        "      /   / \\       |",
                        "     0   0   1      1",
                        "    /|  /|   |    /| |",
                        "   1 2 0 2   0   0 1 2",
                        " ```",
                        " The type of values in indptrBuffers",
                    },
                },
                .{
                    .name = "indptrBuffers",
                    .type = .{ .vector = .{
                        .element_size = 16,
                        .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                        .minalign = 8,
                    } },
                    .required = true,
                    .documentation = .{
                        " indptrBuffers stores the sparsity structure.",
                        " Each two consecutive dimensions in a tensor correspond to a buffer in",
                        " indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`",
                        " and `indptrBuffers[dim][i + 1]` signify a range of nodes in",
                        " `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.",
                        "",
                        " For example, the indptrBuffers for the above X is:",
                        " ```text",
                        "   indptrBuffer(X) = [",
                        "                       [0, 2, 3],",
                        "                       [0, 1, 3, 4],",
                        "                       [0, 2, 4, 5, 8]",
                        "                     ].",
                        " ```",
                    },
                },
                .{
                    .name = "indicesType",
                    .type = .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                    .required = true,
                    .documentation = .{" The type of values in indicesBuffers"},
                },
                .{
                    .name = "indicesBuffers",
                    .type = .{ .vector = .{
                        .element_size = 16,
                        .element = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                        .minalign = 8,
                    } },
                    .required = true,
                    .documentation = .{
                        " indicesBuffers stores values of nodes.",
                        " Each tensor dimension corresponds to a buffer in indicesBuffers.",
                        " For example, the indicesBuffers for the above X is:",
                        " ```text",
                        "   indicesBuffer(X) = [",
                        "                        [0, 1],",
                        "                        [0, 1, 1],",
                        "                        [0, 0, 1, 1],",
                        "                        [1, 2, 0, 2, 0, 0, 1, 2]",
                        "                      ].",
                        " ```",
                    },
                },
                .{
                    .name = "axisOrder",
                    .type = .{ .vector = .{
                        .element_size = 4,
                        .element = .{ .int = .i32 },
                        .minalign = 4,
                    } },
                    .required = true,
                    .documentation = .{
                        " axisOrder stores the sequence in which dimensions were traversed to",
                        " produce the prefix tree.",
                        " For example, the axisOrder for the above X is:",
                        " ```text",
                        "   axisOrder(X) = [0, 1, 2, 3].",
                        " ```",
                    },
                },
            },
            .documentation = .{" Compressed Sparse Fiber (CSF) sparse tensor index."},
        },
        .{
            .name = "org.apache.arrow.flatbuf.Struct_",
            .fields = .{},
            .documentation = .{
                " A Struct_ in the flatbuffer metadata is the same as an Arrow Struct",
                " (according to the physical memory layout). We used Struct_ here as",
                " Struct is a reserved word in Flatbuffers",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.Tensor", .fields = .{
            .{ .name = "type_type", .type = .{ .@"union" = .{ .name = "org.apache.arrow.flatbuf.Type" } } },
            .{
                .name = "shape",
                .type = .{ .vector = .{
                    .element_size = 4,
                    .element = .{ .table = .{ .name = "org.apache.arrow.flatbuf.TensorDim" } },
                    .minalign = 4,
                } },
                .required = true,
                .documentation = .{" The dimensions of the tensor, optionally named"},
            },
            .{
                .name = "strides",
                .type = .{ .vector = .{
                    .element_size = 8,
                    .element = .{ .int = .i64 },
                    .minalign = 8,
                } },
                .documentation = .{ " Non-negative byte offsets to advance one value cell along each dimension", " If omitted, default to row-major order (C-like)." },
            },
            .{
                .name = "data",
                .type = .{ .@"struct" = .{ .name = "org.apache.arrow.flatbuf.Buffer" } },
                .required = true,
                .documentation = .{" The location and size of the tensor's data"},
            },
        } },
        .{
            .name = "org.apache.arrow.flatbuf.TensorDim",
            .fields = .{ .{
                .name = "size",
                .type = .{ .int = .i64 },
                .documentation = .{" Length of dimension"},
            }, .{
                .name = "name",
                .type = .string,
                .documentation = .{" Name of the dimension, optional"},
            } },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " Data structures for dense tensors",
                " Shape data for a single axis in a tensor",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Time",
            .fields = .{ .{
                .name = "unit",
                .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.TimeUnit" } },
                .default_integer = 1,
            }, .{
                .name = "bitWidth",
                .type = .{ .int = .i32 },
                .default_integer = 32,
            } },
            .documentation = .{
                " Time is either a 32-bit or 64-bit signed integer type representing an",
                " elapsed time since midnight, stored in either of four units: seconds,",
                " milliseconds, microseconds or nanoseconds.",
                "",
                " The integer `bitWidth` depends on the `unit` and must be one of the following:",
                " * SECOND and MILLISECOND: 32 bits",
                " * MICROSECOND and NANOSECOND: 64 bits",
                "",
                " The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds",
                " (exclusive), adjusted for the time unit (for example, up to 86400000",
                " exclusive for the MILLISECOND unit).",
                " This definition doesn't allow for leap seconds. Time values from",
                " measurements with leap seconds will need to be corrected when ingesting",
                " into Arrow (for example by replacing the value 86400 with 86399).",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Timestamp",
            .fields = .{ .{ .name = "unit", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.TimeUnit" } } }, .{
                .name = "timezone",
                .type = .string,
                .documentation = .{
                    " The timezone is an optional string indicating the name of a timezone,",
                    " one of:",
                    "",
                    " * As used in the Olson timezone database (the \"tz database\" or",
                    "   \"tzdata\"), such as \"America/New_York\".",
                    " * An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",",
                    "   such as \"+07:30\".",
                    "",
                    " Whether a timezone string is present indicates different semantics about",
                    " the data (see above).",
                },
            } },
            .documentation = .{
                " Timestamp is a 64-bit signed integer representing an elapsed time since a",
                " fixed epoch, stored in either of four units: seconds, milliseconds,",
                " microseconds or nanoseconds, and is optionally annotated with a timezone.",
                "",
                " Timestamp values do not include any leap seconds (in other words, all",
                " days are considered 86400 seconds long).",
                "",
                " Timestamps with a non-empty timezone",
                " ------------------------------------",
                "",
                " If a Timestamp column has a non-empty timezone value, its epoch is",
                " 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone",
                " (the Unix epoch), regardless of the Timestamp's own timezone.",
                "",
                " Therefore, timestamp values with a non-empty timezone correspond to",
                " physical points in time together with some additional information about",
                " how the data was obtained and/or how to display it (the timezone).",
                "",
                "   For example, the timestamp value 0 with the timezone string \"Europe/Paris\"",
                "   corresponds to \"January 1st 1970, 00h00\" in the UTC timezone, but the",
                "   application may prefer to display it as \"January 1st 1970, 01h00\" in",
                "   the Europe/Paris timezone (which is the same physical point in time).",
                "",
                " One consequence is that timestamp values with a non-empty timezone",
                " can be compared and ordered directly, since they all share the same",
                " well-known point of reference (the Unix epoch).",
                "",
                " Timestamps with an unset / empty timezone",
                " -----------------------------------------",
                "",
                " If a Timestamp column has no timezone value, its epoch is",
                " 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.",
                "",
                " Therefore, timestamp values without a timezone cannot be meaningfully",
                " interpreted as physical points in time, but only as calendar / clock",
                " indications (\"wall clock time\") in an unspecified timezone.",
                "",
                "   For example, the timestamp value 0 with an empty timezone string",
                "   corresponds to \"January 1st 1970, 00h00\" in an unknown timezone: there",
                "   is not enough information to interpret it as a well-defined physical",
                "   point in time.",
                "",
                " One consequence is that timestamp values without a timezone cannot",
                " be reliably compared or ordered, since they may have different points of",
                " reference.  In particular, it is *not* possible to interpret an unset",
                " or empty timezone as the same as \"UTC\".",
                "",
                " Conversion between timezones",
                " ----------------------------",
                "",
                " If a Timestamp column has a non-empty timezone, changing the timezone",
                " to a different non-empty value is a metadata-only operation:",
                " the timestamp values need not change as their point of reference remains",
                " the same (the Unix epoch).",
                "",
                " However, if a Timestamp column has no timezone value, changing it to a",
                " non-empty value requires to think about the desired semantics.",
                " One possibility is to assume that the original timestamp values are",
                " relative to the epoch of the timezone being set; timestamp values should",
                " then adjusted to the Unix epoch (for example, changing the timezone from",
                " empty to \"Europe/Paris\" would require converting the timestamp values",
                " from \"Europe/Paris\" to \"UTC\", which seems counter-intuitive but is",
                " nevertheless correct).",
                "",
                " Guidelines for encoding data from external libraries",
                " ----------------------------------------------------",
                "",
                " Date & time libraries often have multiple different data types for temporal",
                " data. In order to ease interoperability between different implementations the",
                " Arrow project has some recommendations for encoding these types into a Timestamp",
                " column.",
                "",
                " An \"instant\" represents a physical point in time that has no relevant timezone",
                " (for example, astronomical data). To encode an instant, use a Timestamp with",
                " the timezone string set to \"UTC\", and make sure the Timestamp values",
                " are relative to the UTC epoch (January 1st 1970, midnight).",
                "",
                " A \"zoned date-time\" represents a physical point in time annotated with an",
                " informative timezone (for example, the timezone in which the data was",
                " recorded).  To encode a zoned date-time, use a Timestamp with the timezone",
                " string set to the name of the timezone, and make sure the Timestamp values",
                " are relative to the UTC epoch (January 1st 1970, midnight).",
                "",
                "  (There is some ambiguity between an instant and a zoned date-time with the",
                "   UTC timezone.  Both of these are stored the same in Arrow.  Typically,",
                "   this distinction does not matter.  If it does, then an application should",
                "   use custom metadata or an extension type to distinguish between the two cases.)",
                "",
                " An \"offset date-time\" represents a physical point in time combined with an",
                " explicit offset from UTC.  To encode an offset date-time, use a Timestamp",
                " with the timezone string set to the numeric timezone offset string",
                " (e.g. \"+03:00\"), and make sure the Timestamp values are relative to",
                " the UTC epoch (January 1st 1970, midnight).",
                "",
                " A \"naive date-time\" (also called \"local date-time\" in some libraries)",
                " represents a wall clock time combined with a calendar date, but with",
                " no indication of how to map this information to a physical point in time.",
                " Naive date-times must be handled with care because of this missing",
                " information, and also because daylight saving time (DST) may make",
                " some values ambiguous or nonexistent. A naive date-time may be",
                " stored as a struct with Date and Time fields. However, it may also be",
                " encoded into a Timestamp column with an empty timezone. The timestamp",
                " values should be computed \"as if\" the timezone of the date-time values",
                " was UTC; for example, the naive date-time \"January 1st 1970, 00h00\" would",
                " be encoded as timestamp value 0.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Union",
            .fields = .{ .{ .name = "mode", .type = .{ .@"enum" = .{ .name = "org.apache.arrow.flatbuf.UnionMode" } } }, .{ .name = "typeIds", .type = .{ .vector = .{
                .element_size = 4,
                .element = .{ .int = .i32 },
                .minalign = 4,
            } } } },
            .documentation = .{
                " A union is a complex type with children in Field",
                " By default ids in the type vector refer to the offsets in the children",
                " optionally typeIds provides an indirection between the child offset and the type id",
                " for each child `typeIds[offset]` is the id used in the type vector",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Utf8",
            .fields = .{},
            .documentation = .{" Unicode with UTF-8 encoding"},
        },
        .{
            .name = "org.apache.arrow.flatbuf.Utf8View",
            .fields = .{},
            .documentation = .{
                " Logically the same as Utf8, but the internal representation uses a view",
                " struct that contains the string length and either the string's entire data",
                " inline (for small strings) or an inlined prefix, an index of another buffer,",
                " and an offset pointing to a slice in that buffer (for non-small strings).",
                "",
                " Since it uses a variable number of data buffers, each Field with this type",
                " must have a corresponding entry in `variadicBufferCounts`.",
            },
        },
    },
    .enums = .{
        .{
            .name = "org.apache.arrow.flatbuf.BodyCompressionMethod",
            .backing_integer = .i8,
            .values = .{.{
                .name = "BUFFER",
                .value = 0,
                .documentation = .{
                    " Each constituent buffer is first compressed with the indicated",
                    " compressor, and then written with the uncompressed length in the first 8",
                    " bytes as a 64-bit little-endian signed integer followed by the compressed",
                    " buffer bytes (and then padding as required by the protocol). The",
                    " uncompressed length may be set to -1 to indicate that the data that",
                    " follows is not compressed, which can be useful for cases where",
                    " compression does not yield appreciable savings.",
                },
            }},
            .documentation = .{
                " Provided for forward compatibility in case we need to support different",
                " strategies for compressing the IPC message body (like whole-body",
                " compression rather than buffer-level) in the future",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.CompressionType",
            .backing_integer = .i8,
            .values = .{ .{ .name = "LZ4_FRAME", .value = 0 }, .{ .name = "ZSTD", .value = 1 } },
        },
        .{
            .name = "org.apache.arrow.flatbuf.DateUnit",
            .backing_integer = .i16,
            .values = .{ .{ .name = "DAY", .value = 0 }, .{ .name = "MILLISECOND", .value = 1 } },
        },
        .{
            .name = "org.apache.arrow.flatbuf.DictionaryKind",
            .backing_integer = .i16,
            .values = .{.{ .name = "DenseArray", .value = 0 }},
            .documentation = .{
                " ----------------------------------------------------------------------",
                " Dictionary encoding metadata",
                " Maintained for forwards compatibility, in the future",
                " Dictionaries might be explicit maps between integers and values",
                " allowing for non-contiguous index values",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Endianness",
            .backing_integer = .i16,
            .values = .{ .{ .name = "Little", .value = 0 }, .{ .name = "Big", .value = 1 } },
            .documentation = .{ " ----------------------------------------------------------------------", " Endianness of the platform producing the data" },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Feature",
            .backing_integer = .i64,
            .values = .{
                .{
                    .name = "UNUSED",
                    .value = 0,
                    .documentation = .{" Needed to make flatbuffers happy."},
                },
                .{
                    .name = "DICTIONARY_REPLACEMENT",
                    .value = 1,
                    .documentation = .{
                        " The stream makes use of multiple full dictionaries with the",
                        " same ID and assumes clients implement dictionary replacement",
                        " correctly.",
                    },
                },
                .{
                    .name = "COMPRESSED_BODY",
                    .value = 2,
                    .documentation = .{ " The stream makes use of compressed bodies as described", " in Message.fbs." },
                },
            },
            .documentation = .{
                " Represents Arrow Features that might not have full support",
                " within implementations. This is intended to be used in",
                " two scenarios:",
                "  1.  A mechanism for readers of Arrow Streams",
                "      and files to understand that the stream or file makes",
                "      use of a feature that isn't supported or unknown to",
                "      the implementation (and therefore can meet the Arrow",
                "      forward compatibility guarantees).",
                "  2.  A means of negotiating between a client and server",
                "      what features a stream is allowed to use. The enums",
                "      values here are intended to represent higher level",
                "      features, additional details may be negotiated",
                "      with key-value pairs specific to the protocol.",
                "",
                " Enums added to this list should be assigned power-of-two values",
                " to facilitate exchanging and comparing bitmaps for supported",
                " features.",
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.IntervalUnit",
            .backing_integer = .i16,
            .values = .{
                .{ .name = "YEAR_MONTH", .value = 0 },
                .{ .name = "DAY_TIME", .value = 1 },
                .{ .name = "MONTH_DAY_NANO", .value = 2 },
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.MetadataVersion",
            .backing_integer = .i16,
            .values = .{
                .{
                    .name = "V1",
                    .value = 0,
                    .documentation = .{" 0.1.0 (October 2016)."},
                },
                .{
                    .name = "V2",
                    .value = 1,
                    .documentation = .{" 0.2.0 (February 2017). Non-backwards compatible with V1."},
                },
                .{
                    .name = "V3",
                    .value = 2,
                    .documentation = .{" 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2."},
                },
                .{
                    .name = "V4",
                    .value = 3,
                    .documentation = .{" >= 0.8.0 (December 2017). Non-backwards compatible with V3."},
                },
                .{
                    .name = "V5",
                    .value = 4,
                    .documentation = .{
                        " >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4",
                        " metadata and IPC messages). Implementations are recommended to provide a",
                        " V4 compatibility mode with V5 format changes disabled.",
                        "",
                        " Incompatible changes between V4 and V5:",
                        " - Union buffer layout has changed. In V5, Unions don't have a validity",
                        "   bitmap buffer.",
                    },
                },
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.Precision",
            .backing_integer = .i16,
            .values = .{
                .{ .name = "HALF", .value = 0 },
                .{ .name = "SINGLE", .value = 1 },
                .{ .name = "DOUBLE", .value = 2 },
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.SparseMatrixCompressedAxis",
            .backing_integer = .i16,
            .values = .{ .{ .name = "Row", .value = 0 }, .{ .name = "Column", .value = 1 } },
        },
        .{
            .name = "org.apache.arrow.flatbuf.TimeUnit",
            .backing_integer = .i16,
            .values = .{
                .{ .name = "SECOND", .value = 0 },
                .{ .name = "MILLISECOND", .value = 1 },
                .{ .name = "MICROSECOND", .value = 2 },
                .{ .name = "NANOSECOND", .value = 3 },
            },
        },
        .{
            .name = "org.apache.arrow.flatbuf.UnionMode",
            .backing_integer = .i16,
            .values = .{ .{ .name = "Sparse", .value = 0 }, .{ .name = "Dense", .value = 1 } },
        },
    },
    .unions = .{
        .{
            .name = "org.apache.arrow.flatbuf.MessageHeader",
            .options = .{
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Schema" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.DictionaryBatch" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.RecordBatch" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Tensor" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.SparseTensor" } },
            },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " The root Message type",
                " This union enables us to easily send different message types without",
                " redundant storage, and in the future we can easily add new message types.",
                "",
                " Arrow implementations do not need to implement all of the message types,",
                " which may include experimental metadata types. For maximum compatibility,",
                " it is best to send data using RecordBatch",
            },
        },
        .{ .name = "org.apache.arrow.flatbuf.SparseTensorIndex", .options = .{
            .{ .table = .{ .name = "org.apache.arrow.flatbuf.SparseTensorIndexCOO" } },
            .{ .table = .{ .name = "org.apache.arrow.flatbuf.SparseMatrixIndexCSX" } },
            .{ .table = .{ .name = "org.apache.arrow.flatbuf.SparseTensorIndexCSF" } },
        } },
        .{
            .name = "org.apache.arrow.flatbuf.Type",
            .options = .{
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Null" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Int" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.FloatingPoint" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Binary" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Utf8" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Bool" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Decimal" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Date" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Time" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Timestamp" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Interval" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.List" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Struct_" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Union" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.FixedSizeBinary" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.FixedSizeList" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Map" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Duration" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.LargeBinary" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.LargeUtf8" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.LargeList" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.RunEndEncoded" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.BinaryView" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.Utf8View" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.ListView" } },
                .{ .table = .{ .name = "org.apache.arrow.flatbuf.LargeListView" } },
            },
            .documentation = .{
                " ----------------------------------------------------------------------",
                " Top-level Type value, enabling extensible type-specific metadata. We can",
                " add new logical types to Type without breaking backwards compatibility",
            },
        },
    },
    .structs = .{
        .{
            .name = "org.apache.arrow.flatbuf.Block",
            .fields = .{
                .{
                    .name = "bodyLength",
                    .type = .{ .int = .i64 },
                    .offset = 16,
                    .documentation = .{ " Length of the data (this is aligned so there can be a gap between this and", " the metadata)." },
                },
                .{
                    .name = "metaDataLength",
                    .type = .{ .int = .i32 },
                    .offset = 8,
                    .documentation = .{" Length of the metadata"},
                },
                .{
                    .name = "offset",
                    .type = .{ .int = .i64 },
                    .offset = 0,
                    .documentation = .{" Index to the start of the RecordBlock (note this is past the Message header)"},
                },
            },
            .bytesize = 24,
            .minalign = 8,
        },
        .{
            .name = "org.apache.arrow.flatbuf.Buffer",
            .fields = .{ .{
                .name = "length",
                .type = .{ .int = .i64 },
                .offset = 8,
                .documentation = .{
                    " The absolute length (in bytes) of the memory buffer. The memory is found",
                    " from offset (inclusive) to offset + length (non-inclusive). When building",
                    " messages using the encapsulated IPC message, padding bytes may be written",
                    " after a buffer, but such padding bytes do not need to be accounted for in",
                    " the size here.",
                },
            }, .{
                .name = "offset",
                .type = .{ .int = .i64 },
                .offset = 0,
                .documentation = .{ " The relative offset into the shared memory page where the bytes for this", " buffer starts" },
            } },
            .bytesize = 16,
            .minalign = 8,
            .documentation = .{ " ----------------------------------------------------------------------", " A Buffer represents a single contiguous memory segment" },
        },
        .{
            .name = "org.apache.arrow.flatbuf.FieldNode",
            .fields = .{ .{
                .name = "length",
                .type = .{ .int = .i64 },
                .offset = 0,
                .documentation = .{ " The number of value slots in the Arrow array at this level of a nested", " tree" },
            }, .{
                .name = "null_count",
                .type = .{ .int = .i64 },
                .offset = 8,
                .documentation = .{
                    " The number of observed nulls. Fields with null_count == 0 may choose not",
                    " to write their physical validity bitmap out as a materialized buffer,",
                    " instead setting the length of the bitmap buffer to 0.",
                },
            } },
            .bytesize = 16,
            .minalign = 8,
            .documentation = .{
                " ----------------------------------------------------------------------",
                " Data structures for describing a table row batch (a collection of",
                " equal-length Arrow arrays)",
                " Metadata about a field at some level of a nested type tree (but not",
                " its children).",
                "",
                " For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`",
                " would have {length: 5, null_count: 2} for its List node, and {length: 6,",
                " null_count: 0} for its Int16 node, as separate FieldNode structs",
            },
        },
    },
    .bit_flags = .{},
}
